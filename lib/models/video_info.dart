import 'package:hive/hive.dart';

part 'video_info.g.dart';

/// Audio quality tiers for merging video with audio
@HiveType(typeId: 3)
enum AudioQuality {
  @HiveField(0)
  high,   // >160 kbps - Best quality, larger file
  @HiveField(1)
  mid,    // 96-160 kbps - Balanced quality/size
  @HiveField(2)
  low,    // <96 kbps - Smaller file size
}

/// Extension to provide audio quality utilities
extension AudioQualityExtension on AudioQuality {
  String get label {
    switch (this) {
      case AudioQuality.high:
        return 'High';
      case AudioQuality.mid:
        return 'Mid';
      case AudioQuality.low:
        return 'Low';
    }
  }

  String get ytdlpValue {
    switch (this) {
      case AudioQuality.high:
        return '0';
      case AudioQuality.mid:
        return '5';
      case AudioQuality.low:
        return '9';
    }
  }

  String get description {
    switch (this) {
      case AudioQuality.high:
        return 'Best quality (>160kbps)';
      case AudioQuality.mid:
        return 'Balanced (96-160kbps)';
      case AudioQuality.low:
        return 'Smaller file (<96kbps)';
    }
  }



  /// Check if a bitrate falls within this quality tier
  bool matchesBitrate(int? bitrate) {
    if (bitrate == null) return this == AudioQuality.high; // Default to high if unknown
    switch (this) {
      case AudioQuality.high:
        return bitrate > 160;
      case AudioQuality.mid:
        return bitrate >= 96 && bitrate <= 160;
      case AudioQuality.low:
        return bitrate < 96;
    }
  }
}

class SubtitleTrack {
  final String languageCode;
  final String name;
  final bool isAutoGenerated;
  final String? ext;

  SubtitleTrack({
    required this.languageCode,
    required this.name,
    this.isAutoGenerated = false,
    this.ext,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SubtitleTrack &&
          runtimeType == other.runtimeType &&
          languageCode == other.languageCode &&
          isAutoGenerated == other.isAutoGenerated;

  @override
  int get hashCode => languageCode.hashCode ^ isAutoGenerated.hashCode;
}

class VideoInfo {
  final String id;
  final String title;
  final String channel;
  final String channelUrl;
  final String thumbnailUrl;
  final int duration; // in seconds
  final String description;
  final int viewCount;
  final String uploadDate;
  final List<FormatInfo> formats;
  final String url;
  final List<SubtitleTrack> subtitles;

  VideoInfo({
    required this.id,
    required this.title,
    required this.channel,
    required this.channelUrl,
    required this.thumbnailUrl,
    required this.duration,
    required this.description,
    required this.viewCount,
    required this.uploadDate,
    required this.formats,
    required this.url,
    required this.subtitles,
  });

  factory VideoInfo.fromJson(Map<String, dynamic> json) {
    final formatsList = (json['formats'] as List<dynamic>?)
        ?.map((f) => FormatInfo.fromJson(f as Map<String, dynamic>))
        .toList() ?? [];

    final subsList = <SubtitleTrack>[];

    // Parse official subtitles
    if (json['subtitles'] != null && json['subtitles'] is Map) {
      final subsMap = json['subtitles'] as Map<String, dynamic>;
      subsMap.forEach((lang, details) {
        String name = lang;
        String? ext;
        if (details is List && details.isNotEmpty) {
          final detail = details.first as Map<String, dynamic>;
          name = detail['name'] ?? lang;
          ext = detail['ext'];
        }
        subsList.add(SubtitleTrack(
          languageCode: lang,
          name: name,
          isAutoGenerated: false,
          ext: ext,
        ));
      });
    }

    // Parse auto-generated captions
    if (json['automatic_captions'] != null && json['automatic_captions'] is Map) {
      final autoMap = json['automatic_captions'] as Map<String, dynamic>;
      autoMap.forEach((lang, details) {
        String name = lang;
        String? ext;
        if (details is List && details.isNotEmpty) {
          final detail = details.first as Map<String, dynamic>;
          name = detail['name'] ?? lang;
          ext = detail['ext'];
        }
        // Only add if not already present as official
        if (!subsList.any((s) => s.languageCode == lang && !s.isAutoGenerated)) {
           subsList.add(SubtitleTrack(
            languageCode: lang,
            name: '$name (Auto)',
            isAutoGenerated: true,
            ext: ext,
          ));
        }
      });
    }

    // Sort: Official English first, then other official, then auto
    subsList.sort((a, b) {
      if (a.isAutoGenerated != b.isAutoGenerated) {
        return a.isAutoGenerated ? 1 : -1;
      }
      if (a.languageCode.startsWith('en') && !b.languageCode.startsWith('en')) return -1;
      if (!a.languageCode.startsWith('en') && b.languageCode.startsWith('en')) return 1;
      return a.name.compareTo(b.name);
    });

    return VideoInfo(
      id: json['id'] ?? '',
      title: json['title'] ?? 'Unknown Title',
      channel: json['channel'] ?? json['uploader'] ?? 'Unknown Channel',
      channelUrl: json['channel_url'] ?? json['uploader_url'] ?? '',
      thumbnailUrl: json['thumbnail'] ?? '',
      duration: json['duration']?.toInt() ?? 0,
      description: json['description'] ?? '',
      viewCount: json['view_count']?.toInt() ?? 0,
      uploadDate: json['upload_date'] ?? '',
      formats: formatsList,
      url: json['webpage_url'] ?? json['url'] ?? '',
      subtitles: subsList,
    );
  }

  /// Get best quality video+audio format
  FormatInfo? get bestVideoFormat {
    final videoFormats = formats
        .where((f) => f.hasVideo && f.hasAudio)
        .toList();
    if (videoFormats.isEmpty) return null;
    videoFormats.sort((a, b) => (b.height ?? 0).compareTo(a.height ?? 0));
    return videoFormats.first;
  }

  /// Get video-only formats sorted by quality
  List<FormatInfo> get videoOnlyFormats {
    final videoFormats = formats
        .where((f) => f.hasVideo && !f.hasAudio)
        .toList();
    videoFormats.sort((a, b) => (b.height ?? 0).compareTo(a.height ?? 0));
    return videoFormats;
  }

  /// Get audio-only formats sorted by quality
  List<FormatInfo> get audioOnlyFormats {
    final audioFormats = formats
        .where((f) => f.hasAudio && !f.hasVideo)
        .toList();
    audioFormats.sort((a, b) => (b.audioBitrate ?? 0).compareTo(a.audioBitrate ?? 0));
    return audioFormats;
  }

  /// Get combined video+audio formats
  List<FormatInfo> get combinedFormats {
    final combined = formats
        .where((f) => f.hasVideo && f.hasAudio)
        .toList();
    combined.sort((a, b) => (b.height ?? 0).compareTo(a.height ?? 0));
    return combined;
  }

  /// Get all available resolutions (unique heights)
  List<int> get availableResolutions {
    final heights = formats
        .where((f) => f.hasVideo && f.height != null)
        .map((f) => f.height!)
        .toSet()
        .toList();
    heights.sort((a, b) => b.compareTo(a));
    return heights;
  }

  String get formattedDuration {
    final hours = duration ~/ 3600;
    final minutes = (duration % 3600) ~/ 60;
    final seconds = duration % 60;
    
    if (hours > 0) {
      return '${hours.toString().padLeft(2, '0')}:${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
    }
    return '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
  }

  String get formattedViewCount {
    if (viewCount >= 1000000000) {
      return '${(viewCount / 1000000000).toStringAsFixed(1)}B views';
    }
    if (viewCount >= 1000000) {
      return '${(viewCount / 1000000).toStringAsFixed(1)}M views';
    }
    if (viewCount >= 1000) {
      return '${(viewCount / 1000).toStringAsFixed(1)}K views';
    }
    return '$viewCount views';
  }

  /// Get audio formats filtered by quality tier
  List<FormatInfo> getAudioFormatsForQuality(AudioQuality quality) {
    final audioFormats = audioOnlyFormats;
    if (audioFormats.isEmpty) return [];
    
    // Filter by bitrate matching the quality tier
    final filtered = audioFormats.where((f) => quality.matchesBitrate(f.audioBitrate)).toList();
    
    // If no formats match the tier, return the closest available
    if (filtered.isEmpty) {
      // For high/mid, try to get something, for low get the lowest
      if (quality == AudioQuality.low) {
        return [audioFormats.last]; // Lowest bitrate
      }
      return [audioFormats.first]; // Highest available
    }
    
    return filtered;
  }

  /// Get best audio format for a quality tier
  FormatInfo? getBestAudioForQuality(AudioQuality quality) {
    final formats = getAudioFormatsForQuality(quality);
    if (formats.isEmpty) {
      // Fallback: return best available if no match
      return audioOnlyFormats.isNotEmpty ? audioOnlyFormats.first : null;
    }
    
    // For high/mid quality, return highest bitrate in tier
    // For low quality, return lowest bitrate in tier
    if (quality == AudioQuality.low) {
      formats.sort((a, b) => (a.audioBitrate ?? 0).compareTo(a.audioBitrate ?? 0));
    } else {
      formats.sort((a, b) => (b.audioBitrate ?? 0).compareTo(a.audioBitrate ?? 0));
    }
    return formats.first;
  }

  /// Get available audio quality tiers for this video
  List<AudioQuality> get availableAudioQualities {
    final audioFormats = audioOnlyFormats;
    if (audioFormats.isEmpty) return [AudioQuality.high]; // Default fallback
    
    final qualities = <AudioQuality>[];
    for (final quality in AudioQuality.values) {
      if (audioFormats.any((f) => quality.matchesBitrate(f.audioBitrate))) {
        qualities.add(quality);
      }
    }
    
    // Always return at least high quality as fallback
    if (qualities.isEmpty) qualities.add(AudioQuality.high);
    return qualities;
  }
}

class FormatInfo {
  final String formatId;
  final String? formatNote;
  final String? extension;
  final int? width;
  final int? height;
  final double? fps;
  final String? videoCodec;
  final String? audioCodec;
  final int? filesize;
  final int? audioBitrate;
  final int? videoBitrate;
  final bool hasAudio;
  final bool hasVideo;
  final String? dynamicRange; // SDR, HDR, HDR10, etc.
  final int? sampleRate; // Audio sample rate

  FormatInfo({
    required this.formatId,
    this.formatNote,
    this.extension,
    this.width,
    this.height,
    this.fps,
    this.videoCodec,
    this.audioCodec,
    this.filesize,
    this.audioBitrate,
    this.videoBitrate,
    required this.hasAudio,
    required this.hasVideo,
    this.dynamicRange,
    this.sampleRate,
  });

  factory FormatInfo.fromJson(Map<String, dynamic> json) {
    return FormatInfo(
      formatId: json['format_id']?.toString() ?? '',
      formatNote: json['format_note']?.toString(),
      extension: json['ext']?.toString(),
      width: json['width']?.toInt(),
      height: json['height']?.toInt(),
      fps: json['fps']?.toDouble(),
      videoCodec: json['vcodec']?.toString(),
      audioCodec: json['acodec']?.toString(),
      filesize: json['filesize']?.toInt() ?? json['filesize_approx']?.toInt(),
      audioBitrate: json['abr']?.toInt(),
      videoBitrate: json['vbr']?.toInt(),
      hasAudio: json['acodec'] != null && json['acodec'] != 'none',
      hasVideo: json['vcodec'] != null && json['vcodec'] != 'none',
      dynamicRange: json['dynamic_range']?.toString(),
      sampleRate: json['asr']?.toInt(),
    );
  }

  String get displayName {
    final parts = <String>[];
    
    if (hasVideo && height != null) {
      parts.add('${height}p');
      if (fps != null && fps! > 30) {
        parts.add('${fps!.round()}fps');
      }
    }
    
    if (hasAudio && audioBitrate != null) {
      parts.add('${audioBitrate}kbps');
    }
    
    if (extension != null) {
      parts.add(extension!.toUpperCase());
    }
    
    return parts.join(' â€¢ ');
  }

  String get qualityLabel {
    if (height != null) {
      if (height! >= 2160) return '4K';
      if (height! >= 1440) return '2K';
      if (height! >= 1080) return 'Full HD';
      if (height! >= 720) return 'HD';
      return '${height}p';
    }
    if (audioBitrate != null) {
      return '${audioBitrate}kbps';
    }
    return formatNote ?? formatId;
  }

  String get formattedFilesize {
    if (filesize == null) return 'Unknown size';
    
    if (filesize! < 1024) return '$filesize B';
    if (filesize! < 1024 * 1024) {
      return '${(filesize! / 1024).toStringAsFixed(1)} KB';
    }
    if (filesize! < 1024 * 1024 * 1024) {
      return '${(filesize! / (1024 * 1024)).toStringAsFixed(1)} MB';
    }
    return '${(filesize! / (1024 * 1024 * 1024)).toStringAsFixed(2)} GB';
  }

  /// Check if this is an HDR format
  bool get isHdr {
    if (dynamicRange != null) {
      final dr = dynamicRange!.toLowerCase();
      return dr.contains('hdr') || dr.contains('hlg') || dr.contains('dv');
    }
    // Fallback: check format note
    if (formatNote != null) {
      final note = formatNote!.toLowerCase();
      return note.contains('hdr') || note.contains('hlg') || note.contains('dolby');
    }
    return false;
  }

  /// Check if this is a 60fps or higher format
  bool get is60fps => fps != null && fps! >= 60;

  /// Get a friendly codec name
  String get codecName {
    if (videoCodec == null || videoCodec == 'none') {
      if (audioCodec != null && audioCodec != 'none') {
        if (audioCodec!.contains('opus')) return 'Opus';
        if (audioCodec!.contains('mp4a') || audioCodec!.contains('aac')) return 'AAC';
        if (audioCodec!.contains('mp3')) return 'MP3';
        return audioCodec!.toUpperCase();
      }
      return 'Unknown';
    }
    if (videoCodec!.contains('av01') || videoCodec!.contains('av1')) return 'AV1';
    if (videoCodec!.contains('vp9') || videoCodec!.contains('vp09')) return 'VP9';
    if (videoCodec!.contains('avc') || videoCodec!.contains('h264')) return 'H.264';
    if (videoCodec!.contains('hevc') || videoCodec!.contains('h265') || videoCodec!.contains('hvc1')) return 'H.265';
    return videoCodec!.toUpperCase();
  }

  /// Get the audio quality tier for this format
  AudioQuality get audioQualityTier {
    if (audioBitrate == null) return AudioQuality.high;
    if (audioBitrate! > 160) return AudioQuality.high;
    if (audioBitrate! >= 96) return AudioQuality.mid;
    return AudioQuality.low;
  }
}
